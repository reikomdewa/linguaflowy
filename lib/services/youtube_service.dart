import 'package:linguaflow/models/lesson_model.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';

class YouTubeService {
  final _yt = YoutubeExplode();

  String _getSearchQuery(String languageCode) {
    // Simplified queries to ensure we get hits
    switch (languageCode) {
      case 'es': return 'Spanish comprehensible input';
      case 'fr': return 'French comprehensible input';
      case 'de': return 'German comprehensible input';
      default: return 'English short stories';
    }
  }

  Future<List<LessonModel>> fetchRecommendedVideos(String languageCode) async {
    print("üé• YOUTUBE: Starting search for '$languageCode'..."); // DEBUG LOG
    
    try {
      final query = _getSearchQuery(languageCode);
      
      // Search
      final searchResults = await _yt.search.search(query);
      print("üé• YOUTUBE: Found ${searchResults.length} videos from search."); // DEBUG LOG

      if (searchResults.isEmpty) return [];

      // Process 5 videos (reduced from 10 for faster debugging)
      final tasks = searchResults.take(5).map((video) => _processVideo(video, languageCode));
      
      final results = await Future.wait(tasks);
      
      final validLessons = results.whereType<LessonModel>().toList();
      print("üé• YOUTUBE: Successfully processed ${validLessons.length} videos."); // DEBUG LOG
      
      return validLessons;
    } catch (e) {
      print("‚ùå YOUTUBE CRITICAL ERROR: $e");
      return [];
    }
  }

Future<LessonModel?> _processVideo(Video video, String languageCode) async {
    try {
      print("   -> Processing: ${video.title}"); 
      
      final manifest = await _yt.videos.closedCaptions.getManifest(video.id);
      
      // FIX: Use the correct class name 'ClosedCaptionTrackInfo' 
      // or just use 'var' to let Dart infer it.
      ClosedCaptionTrackInfo? trackInfo;
      
      try {
        // match starts with (e.g. 'es' matches 'es-MX')
        trackInfo = manifest.tracks.firstWhere(
          (t) => t.language.code.toLowerCase().startsWith(languageCode.toLowerCase()),
        );
      } catch (_) {
        // Fallback: If strict match failed, try to find any track that contains the lang code
        // e.g. languageCode 'es' might match a track labeled 'Spanish' if code is empty (rare)
        try {
           trackInfo = manifest.tracks.firstWhere(
             (t) => t.language.code.toLowerCase().contains(languageCode.toLowerCase())
           );
        } catch(__) {
           // No match found
        }
      }

      if (trackInfo == null) {
        // Optional: specific logic for auto-generated captions if you want them
        // trackInfo = manifest.tracks.firstWhere((t) => t.isAutoGenerated, orElse: () => null);
        
        print("      ‚ö†Ô∏è Skipped: No matching captions found.");
        return null;
      }

      // Fetch Text
      final track = await _yt.videos.closedCaptions.get(trackInfo);
      
      final sb = StringBuffer();
      for (var caption in track.captions) {
        sb.write(caption.text);
        sb.write(" ");
      }
      final content = sb.toString().trim();

      if (content.length < 50) {
        print("      ‚ö†Ô∏è Skipped: Content too short.");
        return null;
      }

      final difficulty = _analyzeDifficulty(content);
      final sentences = _splitIntoSentences(content);

      print("      ‚úÖ Success: ${video.title} (${difficulty})"); 

      return LessonModel(
        id: 'yt_${video.id}',
        userId: 'system',
        title: video.title,
        language: languageCode,
        content: content,
        sentences: sentences,
        createdAt: DateTime.now(),
        imageUrl: video.thumbnails.highResUrl,
        type: 'video',
        difficulty: difficulty,
        videoUrl: video.url,
        isFavorite: false,
      );

    } catch (e) {
      return null;
    }
  }

  String _analyzeDifficulty(String text) {
    if (text.isEmpty) return 'intermediate';
    final words = text.split(' ');
    if (words.isEmpty) return 'intermediate';

    double totalLength = 0;
    for (var word in words) totalLength += word.length;
    
    final avgWordLength = totalLength / words.length;
    final sentenceCount = text.split(RegExp(r'[.!?]+')).length;
    final avgSentenceLength = words.length / (sentenceCount == 0 ? 1 : sentenceCount);

    if (avgWordLength < 4.5 && avgSentenceLength < 12) return 'beginner';
    else if (avgWordLength > 6.0 || avgSentenceLength > 25) return 'advanced';
    else return 'intermediate';
  }

  List<String> _splitIntoSentences(String text) {
    return text
        .split(RegExp(r'[.!?]+'))
        .map((s) => s.trim())
        .where((s) => s.isNotEmpty)
        .toList();
  }
  
  void dispose() {
    _yt.close();
  }
}